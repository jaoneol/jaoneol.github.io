---
title: Understanding Sync vs Async in FastAPI
description: Let's Learn the key differences between Sync and Async in FastAPI.
author: DS2Man
date: 2025-04-17 11:00:00 +0000
categories: [Backend, FastAPI]
tags: [Backend, FastAPI]
math: true
pin: true
---

FastAPI is a modern Python web framework that is optimized for high performance, especially in asynchronous environments. To fully utilize FastAPI's capabilities, it is important to understand the difference between **synchronous** and **asynchronous** programming.

In this post, we will explore how they differ, when to use each, and how they impact your FastAPI application’s performance.

## *What is Synchronous Programming?*

**Synchronous** (or "sync") programming is the traditional way of handling tasks. In synchronous code:
- A function call will **block** the execution until it completes.
- The CPU **waits** for the task to finish before moving on to the next one.

This can be inefficient if the task involves waiting, such as database queries or API requests.

#### *Example: Synchronous Route in FastAPI*

Here, the server **pauses** for 2 seconds and cannot process any other requests during that time.

```python
# routers/model1.py

@router.get("/sync/")
def sync_func(
    question: Optional[str] = None, user_name: Optional[str] = None
):
    try:
        result = {
            "result": "ok",
            "question": question,
            "user_name": user_name,
            "message": "Synchronous processing completed"
        }
        time.sleep(2)
        return result
    except SQLAlchemyError as e:
        raise HTTPException(status_code=500, detail=str(e))
```

```python
url = "http://127.0.0.1:9248/ds2man/model1/sync/"
data = {
    "question": "Where is the captial of Korea?",
    "user_name": "DS2Man"
}

start_time = time.time()
response = requests.get(url, params=data)
end_time = time.time()
elapsed_time = end_time - start_time
print(f"Duration: {elapsed_time:.2f}s")  

print(f"\nResponse:")
pprint(response.json())
```

```bash
Duration: 2.01s

Response:
{'message': 'Synchronous processing completed',
 'question': 'Where is the captial of Korea?',
 'result': 'ok',
 'user_name': 'DS2Man'}
```

## *What is Asynchronous Programming?*

**Asynchronous** (or "async") programming allows your application to handle other tasks while waiting for slow operations to complete:

- Functions declared with `async def` can **pause** at certain points using `await`, freeing the CPU to do other work.  
- Ideal for I/O-bound operations like database access, file reads, or calling external APIs.

#### *Example: Asynchronous Route in FastAPI*

Here, while waiting for 2 seconds, the server can continue handling other requests.

```python
# routers/model1.py

@router.get("/async/")
async def sync_func( # Note. Use `async`
    question: Optional[str] = None, user_name: Optional[str] = None
):
    try:
        result = {
            "result": "ok",
            "question": question,
            "user_name": user_name,
            "message": "Synchronous processing completed"
        }
        await asyncio.sleep(2) # Note. Use `await`
        return result
    except SQLAlchemyError as e:
        raise HTTPException(status_code=500, detail=str(e))
```

```python
url = "http://127.0.0.1:9248/ds2man/model1/async/"
data = {
    "question": "Where is the captial of Korea?",
    "user_name": "DS2Man"
}

start_time = time.time()
response = requests.get(url, params=data)
end_time = time.time()
elapsed_time = end_time - start_time
print(f"Duration: {elapsed_time:.2f}s")  

print(f"\nResponse:")
pprint(response.json())
```

```bash
Duration: 2.02s

Response:
{'message': 'Asynchronous processing completed',
 'question': 'Where is the captial of Korea?',
 'result': 'ok',
 'user_name': 'DS2Man'}
```

## *Key Differences Between Sync and Async*

|Aspect|Synchronous (`def`)|Asynchronous (`async def`)|
|---|---|---|
|CPU Utilization|Blocking (CPU waits)|Non-blocking (CPU can do other work)|
|Performance|Slower under high concurrency|Scales better with many concurrent requests|
|Best Use Cases|CPU-bound tasks|I/O-bound tasks (DB, network, files)|
|Keywords Used|`def`, `time.sleep()`|`async def`, `await`, `asyncio.sleep()`|

## *Using asyncio.gather*

We explored the concepts of synchronous and asynchronous processing. However, in the two examples above, both produced results after 2 seconds, making it difficult to feel the difference between them. To better understand the characteristics of asynchronous execution, I created an example using `asyncio.gather`.

`asyncio.gather()` is a built-in Python function that **runs multiple asynchronous tasks concurrently**. It starts all the tasks at once and waits until **all** of them complete.

Let's dive into how `asyncio.gather()` helps you run multiple async tasks at the same time and improve your application's performance.

```python
# routers/model1.py

async def fake_io(name: str, sec: int):
    start_time = time.time()
    await asyncio.sleep(sec)
    end_time = time.time()
    elapsed_time = end_time - start_time
    now = time.localtime()
    final_time = time.strftime("%Y-%m-%d %H:%M:%S", now)
    return f"{name}, Duration: {elapsed_time:.2f}s, FinalTime: {final_time}"

@router.get("/async/batch")
async def run_tasks(
    question: Optional[str] = None, user_name: Optional[str] = None
):
    tasks = []
    for idx in range(3):
        tasks.append(fake_io(user_name+chr(ord('A') + idx), idx+1))
        
    results = await asyncio.gather(*tasks)

    return {"results": results}
```

```python
import requests
from pprint import pprint

url = "http://127.0.0.1:9248/ds2man/model1/async/batch"
data = {
    "question": "Where is the captial of Korea?",
    "user_name": "DS2Man"
}

start_time = time.time()
response = requests.get(url, params=data)
end_time = time.time()
elapsed_time = end_time - start_time
print(f"Duration: {elapsed_time:.2f}s")

pprint(response.json())
```

```bash
Duration: 3.00s
{'results': ['DS2ManA, Duration: 1.02s, FinalTime: 2025-04-28 11:46:08',
             'DS2ManB, Duration: 2.01s, FinalTime: 2025-04-28 11:46:09',
             'DS2ManC, Duration: 2.99s, FinalTime: 2025-04-28 11:46:10']}
```

As demonstrated in the example above, even though three `fake_io` tasks were executed, they ran simultaneously, and the results were returned in just 3 seconds instead of 6.

## *Conclusion*

Understanding the difference between synchronous and asynchronous programming is essential to building efficient and scalable applications with FastAPI.  
By using `async def` and `await` properly, you can maximize the performance of your app, especially under heavy load with many concurrent users.

In summary:
- Use **synchronous** code for quick, CPU-bound tasks.
- Use **asynchronous** code for I/O-bound operations that involve waiting.

Understanding how to efficiently run multiple asynchronous tasks with `asyncio.gather()` is crucial for building high-performance Python applications. Whether you are making multiple database calls, external API requests, or any other I/O-heavy operations, `asyncio.gather()` helps you speed up the process by running them in parallel — **making your application faster and more scalable**.